package com.roughsea.sorts;

import java.util.Arrays;

public class HeapSort {

    public static void main(String[] args) {
        int[] arr = {1, 51,63, 6, 3, 64, 6, 8, 2, 6, 4,75 ,23};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }

    static void sort(int a[]){
        int N = a.length;
        //Создаём из массива сортирующее дерево
        //Максимальный элемент окажется в корне.
        for (int k = N / 2; k > 0; k--)
            downHeap(a, k, N);
        //Избавляемся от максимумов
        //и перетряхиваем сортирующее дерево
        do {
            //Меняем максимум с последним элементом...
            int T = a[0];
            a[0] = a[N - 1];
            a[N - 1] = T;
            //... и перестравиваем сортирующее дерево
            //для неотсортированной части массива
            N = N - 1;
            downHeap(a, 1, N);
        } while (N > 1); //До последнего элемента
    }

    //Просматриваем ветку и в её корень перемещаем наибольший узел
    static void downHeap(int a[], int k, int N){
        //В корне поддерева
        //запоминаем родителя
        int T = a[k - 1];
        //Смотрим потомков в пределах ветки
        while (k <= N / 2) {
            int j = k + k;//Левый потомок
            //Если есть правый потомок,
            //то сравниваем его с левым
            //и из них выбираем наибольший
            if ((j < N) && (a[j - 1] < a[j])) j++;
            //Если родитель больше (или равен) наибольшего потомка...
            if (T >= a[j - 1]) {
                //... то значит всё в порядке в этой ветке
                break;
            } else { //Если родитель меньше наибольшего потомка...
                //... то потомок становится на место родителя
                a[k - 1] = a[j - 1];
                k = j;
            }
        }
        //Родитель в итоге меняется местами с наибольшим из потомков
        //(или остаётся на своём месте, если все потомки меньше его)
        a[k - 1] = T;
    }
}